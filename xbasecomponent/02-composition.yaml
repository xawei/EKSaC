apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: x-basecomponent
spec:
  compositeTypeRef:
    apiVersion: consumable.trustbank.sg/v1alpha1
    kind: xBaseComponent
  mode: Pipeline
  pipeline:
  - step: install-eks-addons
    functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        name: "eks-addons"
      spec:
        target: Default
        source: |
          import json
          
          oxr = option("params").oxr
          # ocds = option("params").ocds
          
          region = oxr.spec.location
          
          # Default configuration values for different addons
          default_configs = {
            "aws-ebs-csi-driver": {
              controller = {
                tolerations = [
                  {
                    key = "karpenter.sh/nodepool"
                    operator = "Equal"
                    value = "infra"
                    effect = "NoSchedule"
                  }
                ]
              }
            }
            "aws-efs-csi-driver": {
              controller = {
                tolerations = [
                  {
                    key = "karpenter.sh/nodepool"
                    operator = "Equal"
                    value = "infra"
                    effect = "NoSchedule"
                  }
                ]
              }
            }
          }
          
          # Create addon resources for each addon in the list
          items = [
            {
              apiVersion = "eks.aws.upbound.io/v1beta1"
              kind = "Addon"
              metadata.name = oxr.metadata.name + "-" + addon.name.replace("_", "-") + "-addon"
              spec = {
                forProvider = {
                  addonName = addon.name
                  addonVersion = addon.version
                  region = region
                  clusterNameRef.name = oxr.spec.eksClusterRef + "-xplane-eks-cluster"
                  resolveConflicts = "OVERWRITE"
                  # Only set configurationValues if there are actual values to configure
                  configurationValues = json.encode(addon.configurationValues if addon.configurationValues else (default_configs[addon.name] if addon.name in default_configs else {})) if (addon.configurationValues or (addon.name in default_configs and default_configs[addon.name])) else Undefined
                  tags = {
                    Name = oxr.metadata.name + "-" + addon.name + "-addon"
                    ManagedBy = "crossplane"
                  }
                }
                providerConfigRef.name = "provider-aws-eks"
              }
            }
            for addon in (oxr.spec.eksAddons or [])
          ]
  - step: create-s3-bucket-for-velero
    functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        name: "s3-bucket-velero"
      spec:
        target: Default
        source: |
          oxr = option("params").oxr
          
          cluster_name = oxr.spec.eksClusterRef + "-xplane-eks-cluster"
          region = oxr.spec.location
          
          # Only create S3 bucket if Velero is enabled
          items = [
            {
              apiVersion = "s3.aws.upbound.io/v1beta2"
              kind = "Bucket"
              metadata = {
                name = oxr.metadata.name + "-velero-backup-bucket"
                annotations = {
                  "crossplane.io/external-name" = cluster_name + "-velero-backup"
                }
              }
              spec = {
                forProvider = {
                  region = region
                  tags = {
                    Name = cluster_name + "-velero-backup"
                    ManagedBy = "crossplane"
                    Purpose = "velero-backup"
                    "kubernetes.io/cluster/" + cluster_name = "owned"
                  }
                }
                providerConfigRef.name = "provider-aws-s3"
              }
            }
          ] if (oxr.spec.enableVelero or False) else []
  - step: create-efs-filesystem
    functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        name: "efs-filesystem"
      spec:
        target: Default
        source: |
          oxr = option("params").oxr
          
          cluster_name = oxr.spec.eksClusterRef + "-xplane-eks-cluster"
          region = oxr.spec.location
          
          # Only create EFS if EFS CSI driver is enabled
          items = [
            {
              apiVersion = "efs.aws.upbound.io/v1beta1"
              kind = "FileSystem"
              metadata.name = oxr.metadata.name + "-efs-filesystem"
              spec = {
                forProvider = {
                  region = region
                  performanceMode = "generalPurpose"
                  throughputMode = "provisioned"
                  provisionedThroughputInMibps = 100
                  tags = {
                    Name = cluster_name + "-efs"
                    ManagedBy = "crossplane"
                    Purpose = "efs-csi-driver"
                  }
                }
                providerConfigRef.name = "provider-aws-efs"
              }
            }
          ] if (oxr.spec.enableEFSCSIDriver or False) else []
  - step: create-argocd-applicationset
    functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        name: "xplane-argocd-applicationset"
      spec:
        target: Default
        source: |
          import json
          oxr = option("params").oxr
          ocds = option("params").ocds
          labels = oxr.metadata?.labels or {}
          
          cluster_name = oxr.spec.eksClusterRef + "-xplane-eks-cluster"
          region = oxr.spec.location or "unknown"
          aws_account_id = oxr.spec.awsAccountId or "unknown"
          
          # Get S3 bucket name if Velero is enabled
          _s3_bucket_name = ""
          if oxr.spec.enableVelero:
              s3_bucket_resource = ocds[oxr.metadata.name + "-velero-backup-bucket"]?.Resource
              _s3_bucket_name = s3_bucket_resource?.status?.atProvider?.id or ""
          
          # Get EFS filesystem ID if EFS CSI driver is enabled
          _efs_filesystem_id = ""
          if oxr.spec.enableEFSCSIDriver:
              efs_resource = ocds[oxr.metadata.name + "-efs-filesystem"]?.Resource
              _efs_filesystem_id = efs_resource?.status?.atProvider?.id or ""

          # Build base parameters
          base_parameters = [
            {
              name = "cluster.name"
              value = cluster_name
            },
            {
              name = "cluster.region"
              value = region
            },
            {
              name = "cluster.awsAccountId"
              value = aws_account_id
            }
          ]
          
          # Add Velero S3 bucket parameter if enabled
          velero_parameters = [
            {
              name = "velero.s3BucketName"
              value = _s3_bucket_name
            }
          ] if oxr.spec.enableVelero and _s3_bucket_name else []
          
          # Add EFS filesystem ID parameter if enabled
          efs_parameters = [
            {
              name = "efs.filesystemId"
              value = _efs_filesystem_id
            }
          ] if oxr.spec.enableEFSCSIDriver and _efs_filesystem_id else []
          
          # Combine all parameters
          all_parameters = base_parameters + velero_parameters + efs_parameters

          items = [{
            apiVersion = "kubernetes.crossplane.io/v1alpha2"
            kind = "Object"
            metadata.name = oxr.metadata.name + "-xplane-argocd-applicationset"
            spec = {
              forProvider = {
                manifest = {
                  apiVersion = "argoproj.io/v1alpha1"
                  kind = "ApplicationSet"
                  metadata = {
                    name = cluster_name + "-base-components"
                    namespace = "argocd"
                    labels = {
                      "app.kubernetes.io/name" = cluster_name + "-base-components"
                      "app.kubernetes.io/part-of" = "argocd"
                    }
                    finalizers = [
                      "resources-finalizer.argocd.argoproj.io"
                    ]
                  }
                  spec = {
                    goTemplate = True
                    goTemplateOptions = ["missingkey=error"]
                    generators = [
                      {
                        git = {
                          repoURL = "https://github.com/xawei/EKSaC"
                          revision = "HEAD"
                          files = [
                            {
                              path = "base-components/dev/" + cluster_name + "/*.yaml"
                            }
                          ]
                         # Per-application dynamic params (map[string]string).
                         # Key must equal the Application name (filename without .yaml).
                         values = {
                           "aws-load-balancer-controller" = json.encode([
                             {
                               name = "clusterName"
                               value = cluster_name
                             },
                             {
                               name = "region"
                               value = region
                             },
                             {
                               name = "valuesObjectJSON"
                               value = json.encode({
                                 serviceAccount = {
                                   annotations = {
                                     "eks.amazonaws.com/role-arn" = "arn:aws:iam::" + aws_account_id + ":role/ALBControllerRole-" + cluster_name
                                   }
                                 }
                               })
                             }
                           ])
                           "aws-ebs-csi-driver" = json.encode([
                             {
                               name = "valuesObjectJSON"
                               value = json.encode({
                                 controller = {
                                   serviceAccount = {
                                     annotations = {
                                       "eks.amazonaws.com/role-arn" = "arn:aws:iam::" + aws_account_id + ":role/EbsCsiRole-" + cluster_name
                                     }
                                   }
                                 }
                               })
                             }
                           ])
                           "aws-efs-csi-driver" = json.encode([
                             {
                               name = "fileSystemId"
                               value = _efs_filesystem_id
                             },
                             {
                               name = "valuesObjectJSON"
                               value = json.encode({
                                 controller = {
                                   serviceAccount = {
                                     annotations = {
                                       "eks.amazonaws.com/role-arn" = "arn:aws:iam::" + aws_account_id + ":role/EfsCsiRole-" + cluster_name
                                     }
                                   }
                                 }
                               })
                             }
                           ]) if (oxr.spec.enableEFSCSIDriver and _efs_filesystem_id) else Undefined
                           "external-dns" = json.encode([
                             {
                               name = "clusterName"
                               value = cluster_name
                             },
                             {
                               name = "valuesObjectJSON"
                               value = json.encode({
                                 serviceAccount = {
                                   annotations = {
                                     "eks.amazonaws.com/role-arn" = "arn:aws:iam::" + aws_account_id + ":role/ExternalDNS-" + cluster_name
                                   }
                                 }
                               })
                             }
                           ])
                           "velero" = json.encode([
                             {
                               name = "s3BucketName"
                               value = _s3_bucket_name
                             },
                             {
                               name = "regionBackup"
                               value = region
                             },
                             {
                               name = "regionSnapshot"
                               value = region
                             },
                             {
                               name = "valuesObjectJSON"
                               value = json.encode({
                                 serviceAccount = {
                                   server = {
                                     annotations = {
                                       "eks.amazonaws.com/role-arn" = "arn:aws:iam::" + aws_account_id + ":role/VeleroRole-" + cluster_name
                                     }
                                   }
                                 }
                               })
                             }
                           ]) if oxr.spec.enableVelero else Undefined
                         }
                        }
                      }
                    ]
                    template = {
              metadata = {
                name = "{{ trimSuffix \".yaml\" .path.filenameNormalized }}"
                annotations = { "argocd.argoproj.io/sync-wave" = "{{ .wave }}" }
              }
              spec = {
                project = "default"
                destination = { server = "https://kubernetes.default.svc", namespace = "{{ .namespace }}" }
                sources = []
                syncPolicy = {
                  automated  = { prune = True, selfHeal = True }
                  syncOptions = ["CreateNamespace=true", "Replace=true"]
                }
              }
            }

                    templatePatch = """
                      {{- $chartName := trimSuffix ".yaml" .path.filenameNormalized }}
                      {{- $hasHelm := index $ "helm" }}
                      {{- $hasValuesForChart := (and (index . "values") (index .values $chartName)) }}
                      
                      spec:
                        sources:
                          - repoURL: '{{ .repoURL }}'
                            targetRevision: '{{ .targetRevision }}'
                            {{- if $hasHelm }}
                            chart: {{ .helm.chart }}
                            helm:
                              {{- $baseValues := (index .helm "values") | default (dict) }}
                              {{- $extra := dict }}
                              {{- if $hasValuesForChart }}
                              {{- range $p := fromJson (index .values $chartName) }}
                              {{- if eq $p.name "valuesObjectJSON" }}
                              {{- $extra = fromJson (printf "%v" $p.value) }}
                              {{- end }}
                              {{- end }}
                              {{- end }}
                              valuesObject: {{ toJson (merge $baseValues $extra) }}
                              {{- if index .helm "valueFiles" }}
                              valueFiles: {{ toJson .helm.valueFiles }}
                              {{- end }}
                              parameters:
                              {{ if $hasValuesForChart }}
                              {{ range $parameter := fromJson (index .values $chartName) }}
                              {{- if ne $parameter.name "valuesObjectJSON" }}
                              {{ $helm := index $ "helm" }}
                              {{ if $helm }}
                              {{ $po := index $helm "parameterOverrides" }}
                              {{ if $po }}
                              {{ $mapped := index $po $parameter.name }}
                              {{ if $mapped }}
                              - name: {{ $mapped }}
                                value: '{{ printf "%v" $parameter.value }}'
                              {{ else }}
                              - name: {{ $parameter.name }}
                                value: '{{ printf "%v" $parameter.value }}'
                              {{ end }}
                              {{ else }}
                              - name: {{ $parameter.name }}
                                value: '{{ printf "%v" $parameter.value }}'
                              {{ end }}
                              {{ else }}
                              - name: {{ $parameter.name }}
                                value: '{{ printf "%v" $parameter.value }}'
                              {{ end }}
                              {{- end }}
                              {{ end }}
                              {{ end }}
                               # removed cluster-wide parameter injection; rely on per-app parameterOverrides
                            {{- end }}
                            {{- if index . "repoPath" }}
                            path: {{ .repoPath }}
                            {{- end }}
                        {{- if and $hasHelm (index .helm "valueFilesSource") }}
                          - {{ toJson .helm.valueFilesSource }}
                        {{- end }}
                    """
                  }
                }
              }
              managementPolicies = ["Create", "Update", "Observe", "Delete"]
              providerConfigRef.name = oxr.spec.eksClusterRef + "-providerconfig-kubernetes"
            }
          }]
  - step: create-iam-roles-and-associations
    functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        name: "iam-roles-and-podidentity"
      spec:
        target: Default
        source: |

          import json
          oxr = option("params").oxr

          cluster_name = oxr.spec.eksClusterRef + "-xplane-eks-cluster"
          region = oxr.spec.location
          aws_account_id = oxr.spec.awsAccountId

          trust_policy = {
            "Version" = "2012-10-17"
            "Statement" = [
              {
                "Effect" = "Allow"
                "Principal" = {"Service" = "pods.eks.amazonaws.com"}
                "Action" = ["sts:AssumeRole", "sts:TagSession"]
                "Condition" = {
                  "StringEquals" = { "aws:SourceAccount" = aws_account_id }
                  "ArnLike" = { "aws:SourceArn" = "arn:aws:eks:" + region + ":" + aws_account_id + ":podidentityassociation/*" }
                }
              }
            ]
          }


          apps = [
            { name = "ebs-csi",     ns = "kube-system", sa = "ebs-csi-controller-sa",         role = "ebs-csi-role-" + cluster_name,         awsManaged = ["arn:aws:iam::aws:policy/service-role/AmazonEBSCSIDriverPolicy"] },
            { name = "efs-csi",     ns = "kube-system", sa = "efs-csi-controller-sa",         role = "efs-csi-role-" + cluster_name,         awsManaged = ["arn:aws:iam::aws:policy/service-role/AmazonEFSCSIDriverPolicy"] },
            { name = "alb-controller", ns = "kube-system", sa = "aws-load-balancer-controller", role = "alb-controller-role-" + cluster_name,   awsManaged = [] },
            { name = "external-dns",  ns = "external-dns", sa = "external-dns-sa",             role = "external-dns-" + cluster_name,         awsManaged = [] },
            { name = "velero",        ns = "velero",      sa = "velero-server",                role = "velero-role-" + cluster_name,          awsManaged = [] },
          ]

          roles = [
            {
              apiVersion = "iam.aws.upbound.io/v1beta1",
              kind = "Role",
              metadata = { name = app.role, annotations = {"crossplane.io/external-name" = app.role} },
              spec = {
                forProvider = { assumeRolePolicy = json.encode(trust_policy), tags = { ManagedBy = "crossplane", App = app.name } },
                providerConfigRef = { name = "provider-aws-iam" }
              }
            }
            for app in apps
          ]

          policies = [
            {
              apiVersion = "iam.aws.upbound.io/v1beta1",
              kind = "Policy",
              metadata = { name = app.role + "-policy", annotations = {"crossplane.io/external-name" = app.role + "-policy"} },
              spec = { forProvider = { description = "Cluster policy for " + app.name, policy = json.encode({"Version" = "2012-10-17", "Statement" = [ {"Effect" = "Allow", "Action" = ["sts:TagSession"], "Resource" = "*"} ]}) }, providerConfigRef = { name = "provider-aws-iam" } }
            }
            for app in apps if app.name not in ["ebs-csi", "efs-csi"]
          ]

          

          rolePolicies_external_dns = [
            {
              apiVersion = "iam.aws.upbound.io/v1beta1"
              kind = "RolePolicy"
              metadata = { name = app.name + "-inline-policy-" + cluster_name }
              spec = {
                forProvider = {
                  role = app.role
                  policy = json.encode({
                    "Version" = "2012-10-17"
                    "Statement" = [
                      {"Sid" = "GrantModifyAccessToDomain", "Effect" = "Allow", "Action" = ["route53:ChangeResourceRecordSets"], "Resource" = ["arn:aws:route53:::hostedzone/*"]},
                      {"Sid" = "GrantGetChangeStatus", "Effect" = "Allow", "Action" = ["route53:GetChange"], "Resource" = "arn:aws:route53:::change/*"},
                      {"Sid" = "GrantListAccessToDomain", "Effect" = "Allow", "Action" = ["route53:ListResourceRecordSets", "route53:ListHostedZonesByName", "route53:ListHostedZones"], "Resource" = "*"}
                    ]
                  })
                }
                providerConfigRef = { name = "provider-aws-iam" }
              }
            }
            for app in apps if app.name == "external-dns"
          ]

          

          rolePolicies_velero = [
            {
              apiVersion = "iam.aws.upbound.io/v1beta1"
              kind = "RolePolicy"
              metadata = { name = app.name + "-inline-policy-" + cluster_name }
              spec = {
                forProvider = {
                  role = app.role
                  policy = json.encode({
                    "Version" = "2012-10-17",
                    "Statement" = [
                      {"Effect" = "Allow", "Action" = [
                        "ec2:DescribeVolumes","ec2:DescribeSnapshots","ec2:DeleteSnapshot","ec2:CreateVolume","ec2:CreateTags","ec2:CreateSnapshot"
                      ], "Resource" = "*"},
                      {"Effect" = "Allow", "Action" = [
                        "s3:PutObject","s3:ListMultipartUploadParts","s3:GetObject","s3:AbortMultipartUpload"
                      ], "Resource" = ["arn:aws:s3:::" + (cluster_name + "-velero-backup") + "/*"]},
                      {"Effect" = "Allow", "Action" = ["s3:ListBucket"], "Resource" = ["arn:aws:s3:::" + (cluster_name + "-velero-backup")]}
                    ]
                  })
                }
                providerConfigRef = { name = "provider-aws-iam" }
              }
            }
            for app in apps if app.name == "velero"
          ]

          rolePolicies_alb = [
            {
              apiVersion = "iam.aws.upbound.io/v1beta1"
              kind = "RolePolicy"
              metadata = { name = app.name + "-inline-policy-" + cluster_name }
              spec = {
                forProvider = {
                  role = app.role
                  policy = json.encode({
                    "Version" = "2012-10-17",
                    "Statement" = [
                      {"Effect" = "Allow", "Action" = ["iam:CreateServiceLinkedRole"], "Resource" = "*", "Condition" = {"StringEquals" = {"iam:AWSServiceName" = "elasticloadbalancing.amazonaws.com"}}},
                      {"Effect" = "Allow", "Action" = ["ec2:DescribeAccountAttributes","ec2:DescribeAddresses","ec2:DescribeAvailabilityZones","ec2:DescribeInternetGateways","ec2:DescribeVpcs","ec2:DescribeVpcPeeringConnections","ec2:DescribeSubnets","ec2:DescribeSecurityGroups","ec2:DescribeInstances","ec2:DescribeNetworkInterfaces","ec2:DescribeTags","ec2:GetCoipPoolUsage","ec2:DescribeCoipPools","ec2:GetSecurityGroupsForVpc","ec2:DescribeIpamPools","ec2:DescribeRouteTables","elasticloadbalancing:DescribeLoadBalancers","elasticloadbalancing:DescribeLoadBalancerAttributes","elasticloadbalancing:DescribeListeners","elasticloadbalancing:DescribeListenerCertificates","elasticloadbalancing:DescribeSSLPolicies","elasticloadbalancing:DescribeRules","elasticloadbalancing:DescribeTargetGroups","elasticloadbalancing:DescribeTargetGroupAttributes","elasticloadbalancing:DescribeTargetHealth","elasticloadbalancing:DescribeTags","elasticloadbalancing:DescribeTrustStores","elasticloadbalancing:DescribeListenerAttributes","elasticloadbalancing:DescribeCapacityReservation"], "Resource" = "*"},
                      {"Effect" = "Allow", "Action" = ["cognito-idp:DescribeUserPoolClient","acm:ListCertificates","acm:DescribeCertificate","iam:ListServerCertificates","iam:GetServerCertificate","waf-regional:GetWebACL","waf-regional:GetWebACLForResource","waf-regional:AssociateWebACL","waf-regional:DisassociateWebACL","wafv2:GetWebACL","wafv2:GetWebACLForResource","wafv2:AssociateWebACL","wafv2:DisassociateWebACL","shield:GetSubscriptionState","shield:DescribeProtection","shield:CreateProtection","shield:DeleteProtection"], "Resource" = "*"},
                      {"Effect" = "Allow", "Action" = ["ec2:AuthorizeSecurityGroupIngress","ec2:RevokeSecurityGroupIngress"], "Resource" = "*"},
                      {"Effect" = "Allow", "Action" = ["ec2:CreateSecurityGroup"], "Resource" = "*"},
                      {"Effect" = "Allow", "Action" = ["ec2:CreateTags"], "Resource" = "arn:aws:ec2:*:*:security-group/*", "Condition" = {"StringEquals" = {"ec2:CreateAction" = "CreateSecurityGroup"}, "Null" = {"aws:RequestTag/elbv2.k8s.aws/cluster" = "false"}}},
                      {"Effect" = "Allow", "Action" = ["ec2:CreateTags","ec2:DeleteTags"], "Resource" = "arn:aws:ec2:*:*:security-group/*", "Condition" = {"Null" = {"aws:RequestTag/elbv2.k8s.aws/cluster" = "true", "aws:ResourceTag/elbv2.k8s.aws/cluster" = "false"}}},
                      {"Effect" = "Allow", "Action" = ["ec2:AuthorizeSecurityGroupIngress","ec2:RevokeSecurityGroupIngress","ec2:DeleteSecurityGroup"], "Resource" = "*", "Condition" = {"Null" = {"aws:ResourceTag/elbv2.k8s.aws/cluster" = "false"}}},
                      {"Effect" = "Allow", "Action" = ["elasticloadbalancing:CreateLoadBalancer","elasticloadbalancing:CreateTargetGroup"], "Resource" = "*", "Condition" = {"Null" = {"aws:RequestTag/elbv2.k8s.aws/cluster" = "false"}}},
                      {"Effect" = "Allow", "Action" = ["elasticloadbalancing:CreateListener","elasticloadbalancing:DeleteListener","elasticloadbalancing:CreateRule","elasticloadbalancing:DeleteRule"], "Resource" = "*"},
                      {"Effect" = "Allow", "Action" = ["elasticloadbalancing:AddTags","elasticloadbalancing:RemoveTags"], "Resource" = ["arn:aws:elasticloadbalancing:*:*:targetgroup/*/*","arn:aws:elasticloadbalancing:*:*:loadbalancer/net/*/*","arn:aws:elasticloadbalancing:*:*:loadbalancer/app/*/*"], "Condition" = {"Null" = {"aws:RequestTag/elbv2.k8s.aws/cluster" = "true", "aws:ResourceTag/elbv2.k8s.aws/cluster" = "false"}}},
                      {"Effect" = "Allow", "Action" = ["elasticloadbalancing:AddTags","elasticloadbalancing:RemoveTags"], "Resource" = ["arn:aws:elasticloadbalancing:*:*:listener/net/*/*/*","arn:aws:elasticloadbalancing:*:*:listener/app/*/*/*","arn:aws:elasticloadbalancing:*:*:listener-rule/net/*/*/*","arn:aws:elasticloadbalancing:*:*:listener-rule/app/*/*/*"]},
                      {"Effect" = "Allow", "Action" = ["elasticloadbalancing:ModifyLoadBalancerAttributes","elasticloadbalancing:SetIpAddressType","elasticloadbalancing:SetSecurityGroups","elasticloadbalancing:SetSubnets","elasticloadbalancing:DeleteLoadBalancer","elasticloadbalancing:ModifyTargetGroup","elasticloadbalancing:ModifyTargetGroupAttributes","elasticloadbalancing:DeleteTargetGroup","elasticloadbalancing:ModifyListenerAttributes","elasticloadbalancing:ModifyCapacityReservation","elasticloadbalancing:ModifyIpPools"], "Resource" = "*", "Condition" = {"Null" = {"aws:ResourceTag/elbv2.k8s.aws/cluster" = "false"}}},
                      {"Effect" = "Allow", "Action" = ["elasticloadbalancing:AddTags"], "Resource" = ["arn:aws:elasticloadbalancing:*:*:targetgroup/*/*","arn:aws:elasticloadbalancing:*:*:loadbalancer/net/*/*","arn:aws:elasticloadbalancing:*:*:loadbalancer/app/*/*"], "Condition" = {"StringEquals" = {"elasticloadbalancing:CreateAction" = ["CreateTargetGroup","CreateLoadBalancer"]}, "Null" = {"aws:RequestTag/elbv2.k8s.aws/cluster" = "false"}}},
                      {"Effect" = "Allow", "Action" = ["elasticloadbalancing:RegisterTargets","elasticloadbalancing:DeregisterTargets"], "Resource" = "arn:aws:elasticloadbalancing:*:*:targetgroup/*/*"},
                      {"Effect" = "Allow", "Action" = ["elasticloadbalancing:SetWebAcl","elasticloadbalancing:ModifyListener","elasticloadbalancing:AddListenerCertificates","elasticloadbalancing:RemoveListenerCertificates","elasticloadbalancing:ModifyRule","elasticloadbalancing:SetRulePriorities"], "Resource" = "*"}
                    ]
                  })
                }
                providerConfigRef = { name = "provider-aws-iam" }
              }
            }
            for app in apps if app.name == "alb-controller"
          ]



          rolePolicies_inline = rolePolicies_external_dns + rolePolicies_velero + rolePolicies_alb


          attachments_aws = [
            {
              apiVersion = "iam.aws.upbound.io/v1beta1",
              kind = "RolePolicyAttachment",
              metadata = { generateName = app.name + "-aws-attach-", annotations = {"krm.kcl.dev/composition-resource-name" = app.name + "-aws-attach-" + arn} },
              spec = { forProvider = { policyArn = arn, role = app.role }, providerConfigRef = { name = "provider-aws-iam" } }
            }
            for app in apps
            for arn in (app.awsManaged or [])
          ]

          associations = [
            {
              apiVersion = "eks.aws.upbound.io/v1beta1",
              kind = "PodIdentityAssociation",
              metadata = { name = app.name + "-pod-identity-" + cluster_name },
              spec = {
                forProvider = {
                  clusterNameRef = { name = cluster_name },
                  namespace = app.ns,
                  serviceAccount = app.sa,
                  roleArn = "arn:aws:iam::" + aws_account_id + ":role/" + app.role,
                  region = region
                },
                providerConfigRef = { name = "provider-aws-eks" }
              }
            }
            for app in apps
          ]

          items = roles + policies + rolePolicies_inline + attachments_aws + associations

  - step: teardown-sequence
    functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        name: teardown-sequence
      spec:
        target: Default
        source: |
          oxr = option("params").oxr

          # Reference the actual EKS cluster managed resource instead of the composite
          applicationset_usage = {
            apiVersion = "apiextensions.crossplane.io/v1alpha1"
            kind = "Usage"
            metadata.name = oxr.metadata.name + "-applicationset-usage"
            spec = {
              of = {
                apiVersion = "eks.aws.upbound.io/v1beta1"
                kind = "Cluster"
                resourceRef.name = oxr.spec.eksClusterRef + "-xplane-eks-cluster"
              }
              by = {
                apiVersion = "kubernetes.crossplane.io/v1alpha2"
                kind = "Object"
                resourceRef.name = oxr.metadata.name + "-xplane-argocd-applicationset"
              }
            }
          }

          items = [applicationset_usage]
  - step: auto-ready
    functionRef:
      name: function-auto-ready
  - step: creation-sequence
    functionRef:
      name: function-sequencer
    input:
      apiVersion: sequencer.fn.crossplane.io/v1beta1
      kind: Input
      metadata:
        name: creation-sequence
        namespace: eksac
      rules:
      - sequence:
        - "eks-addons"
        - "s3-bucket-velero"
        - "efs-filesystem"
        - "xplane-argocd-applicationset"
        - "iam-roles-and-podidentity"
