apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: x-basecomponent
spec:
  compositeTypeRef:
    apiVersion: consumable.trustbank.sg/v1alpha1
    kind: xBaseComponent
  mode: Pipeline
  pipeline:
  - step: install-eks-addons
    functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        name: "eks-addons"
      spec:
        target: Default
        source: |
          import json
          
          oxr = option("params").oxr
          # ocds = option("params").ocds
          
          region = oxr.spec.location
          
          # Default configuration values for different addons
          default_configs = {
            "aws-ebs-csi-driver": {
              controller = {
                tolerations = [
                  {
                    key = "karpenter.sh/nodepool"
                    operator = "Equal"
                    value = "infra"
                    effect = "NoSchedule"
                  }
                ]
              }
            }
            "aws-efs-csi-driver": {
              controller = {
                tolerations = [
                  {
                    key = "karpenter.sh/nodepool"
                    operator = "Equal"
                    value = "infra"
                    effect = "NoSchedule"
                  }
                ]
              }
            }
          }
          
          # Create addon resources for each addon in the list
          items = [
            {
              apiVersion = "eks.aws.upbound.io/v1beta1"
              kind = "Addon"
              metadata.name = oxr.metadata.name + "-" + addon.name.replace("_", "-") + "-addon"
              spec = {
                forProvider = {
                  addonName = addon.name
                  addonVersion = addon.version
                  region = region
                  clusterNameRef.name = oxr.spec.eksClusterRef + "-xplane-eks-cluster"
                  resolveConflicts = "OVERWRITE"
                  # Only set configurationValues if there are actual values to configure
                  configurationValues = json.encode(addon.configurationValues if addon.configurationValues else (default_configs[addon.name] if addon.name in default_configs else {})) if (addon.configurationValues or (addon.name in default_configs and default_configs[addon.name])) else Undefined
                  tags = {
                    Name = oxr.metadata.name + "-" + addon.name + "-addon"
                    ManagedBy = "crossplane"
                  }
                }
                providerConfigRef.name = "provider-aws-eks"
              }
            }
            for addon in (oxr.spec.eksAddons or [])
          ]
  - step: create-s3-bucket-for-velero
    functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        name: "s3-bucket-velero"
      spec:
        target: Default
        source: |
          oxr = option("params").oxr
          
          cluster_name = oxr.spec.eksClusterRef + "-xplane-eks-cluster"
          region = oxr.spec.location
          
          # Only create S3 bucket if Velero is enabled
          items = [
            {
              apiVersion = "s3.aws.upbound.io/v1beta2"
              kind = "Bucket"
              metadata = {
                name = oxr.metadata.name + "-velero-backup-bucket"
                annotations = {
                  "crossplane.io/external-name" = cluster_name + "-velero-backup"
                }
              }
              spec = {
                forProvider = {
                  region = region
                  tags = {
                    Name = cluster_name + "-velero-backup"
                    ManagedBy = "crossplane"
                    Purpose = "velero-backup"
                    "kubernetes.io/cluster/" + cluster_name = "owned"
                  }
                }
                providerConfigRef.name = "provider-aws-s3"
              }
            }
          ] if (oxr.spec.enableVelero or False) else []
  - step: create-efs-filesystem
    functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        name: "efs-filesystem"
      spec:
        target: Default
        source: |
          oxr = option("params").oxr
          
          cluster_name = oxr.spec.eksClusterRef + "-xplane-eks-cluster"
          region = oxr.spec.location
          
          # Only create EFS if EFS CSI driver is enabled
          items = [
            {
              apiVersion = "efs.aws.upbound.io/v1beta1"
              kind = "FileSystem"
              metadata.name = oxr.metadata.name + "-efs-filesystem"
              spec = {
                forProvider = {
                  region = region
                  performanceMode = "generalPurpose"
                  throughputMode = "provisioned"
                  provisionedThroughputInMibps = 100
                  tags = {
                    Name = cluster_name + "-efs"
                    ManagedBy = "crossplane"
                    Purpose = "efs-csi-driver"
                  }
                }
                providerConfigRef.name = "provider-aws-efs"
              }
            }
          ] if (oxr.spec.enableEFSCSIDriver or False) else []
  - step: create-argocd-applicationset
    functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        name: "xplane-argocd-applicationset"
      spec:
        target: Default
        source: |
          import json
          oxr = option("params").oxr
          ocds = option("params").ocds
          labels = oxr.metadata?.labels or {}
          
          cluster_name = oxr.spec.eksClusterRef + "-xplane-eks-cluster"
          region = oxr.spec.location or "unknown"
          aws_account_id = oxr.spec.awsAccountId or "unknown"
          
          # Get S3 bucket name if Velero is enabled
          _s3_bucket_name = ""
          if oxr.spec.enableVelero:
              s3_bucket_resource = ocds[oxr.metadata.name + "-velero-backup-bucket"]?.Resource
              _s3_bucket_name = s3_bucket_resource?.status?.atProvider?.id or ""
          
          # Get EFS filesystem ID if EFS CSI driver is enabled
          _efs_filesystem_id = ""
          if oxr.spec.enableEFSCSIDriver:
              efs_resource = ocds[oxr.metadata.name + "-efs-filesystem"]?.Resource
              _efs_filesystem_id = efs_resource?.status?.atProvider?.id or ""

          # Build base parameters
          base_parameters = [
            {
              name = "cluster.name"
              value = cluster_name
            },
            {
              name = "cluster.region"
              value = region
            },
            {
              name = "cluster.awsAccountId"
              value = aws_account_id
            }
          ]
          
          # Add Velero S3 bucket parameter if enabled
          velero_parameters = [
            {
              name = "velero.s3BucketName"
              value = _s3_bucket_name
            }
          ] if oxr.spec.enableVelero and _s3_bucket_name else []
          
          # Add EFS filesystem ID parameter if enabled
          efs_parameters = [
            {
              name = "efs.filesystemId"
              value = _efs_filesystem_id
            }
          ] if oxr.spec.enableEFSCSIDriver and _efs_filesystem_id else []
          
          # Combine all parameters
          all_parameters = base_parameters + velero_parameters + efs_parameters

          items = [{
            apiVersion = "kubernetes.crossplane.io/v1alpha2"
            kind = "Object"
            metadata.name = oxr.metadata.name + "-xplane-argocd-applicationset"
            spec = {
              forProvider = {
                manifest = {
                  apiVersion = "argoproj.io/v1alpha1"
                  kind = "ApplicationSet"
                  metadata = {
                    name = cluster_name + "-base-components"
                    namespace = "argocd"
                    labels = {
                      "app.kubernetes.io/name" = cluster_name + "-base-components"
                      "app.kubernetes.io/part-of" = "argocd"
                    }
                    finalizers = [
                      "resources-finalizer.argocd.argoproj.io"
                    ]
                  }
                  spec = {
                    goTemplate = True
                    goTemplateOptions = ["missingkey=error"]
                    generators = [
                      {
                        git = {
                          repoURL = "https://github.com/xawei/EKSaC"
                          revision = "HEAD"
                          files = [
                            {
                              path = "base-components/dev/" + cluster_name + "/*.yaml"
                            }
                          ]
                         # Per-application dynamic params (map[string]string).
                         # Key must equal the Application name (filename without .yaml).
                         values = {
                           "aws-efs-csi-driver" = json.encode([
                             {
                               name = "fileSystemId"
                               value = _efs_filesystem_id
                             }
                           ]) if (oxr.spec.enableEFSCSIDriver and _efs_filesystem_id) else Undefined
                           "velero" = json.encode([
                             {
                               name = "s3BucketName"
                               value = _s3_bucket_name
                             }
                           ]) if (oxr.spec.enableVelero and _s3_bucket_name) else Undefined
                         }
                        }
                      }
                    ]
                    template = {
              metadata = {
                name = "{{ trimSuffix \".yaml\" .path.filenameNormalized }}"
                annotations = { "argocd.argoproj.io/sync-wave" = "{{ .wave }}" }
              }
              spec = {
                project = "default"
                destination = { server = "https://kubernetes.default.svc", namespace = "{{ .namespace }}" }
                sources = []
                syncPolicy = {
                  automated  = { prune = True, selfHeal = True }
                  syncOptions = ["CreateNamespace=true", "Replace=true"]
                }
              }
            }

                    templatePatch = """
                      {{- $chartName := trimSuffix ".yaml" .path.filenameNormalized }}
                      {{- $hasHelm := index . "helm" }}
                      {{- $hasValuesForChart := (and (index . "values") (index .values $chartName)) }}
                      
                      spec:
                        sources:
                          - repoURL: '{{ .repoURL }}'
                            targetRevision: '{{ .targetRevision }}'
                            {{- if $hasHelm }}
                            chart: {{ .helm.chart }}
                            helm:
                              {{- if index .helm "values" }}
                              valuesObject: {{ toJson .helm.values }}
                              {{- end }}
                              {{- if index .helm "valueFiles" }}
                              valueFiles: {{ toJson .helm.valueFiles }}
                              {{- end }}
                              {{- end }}
                            {{- if $hasValuesForChart }}
                            parameters:
                            {{- range $parameter := fromJson (index .values $chartName) }}
                            - name: {{ index $.helm "parameterOverrides" $parameter.name | default $parameter.name }}
                              value: {{ $parameter.value }}
                            {{- end }}
                            {{- end }}
                            {{- if index . "repoPath" }}
                            path: {{ .repoPath }}
                            {{- end }}
                        {{- if and $hasHelm (index .helm "valueFilesSource") }}
                          - {{ toJson .helm.valueFilesSource }}
                              {{- end }}
                    """
                  }
                }
              }
              managementPolicies = ["Create", "Update", "Observe", "Delete"]
              providerConfigRef.name = oxr.spec.eksClusterRef + "-providerconfig-kubernetes"
            }
          }]
  - step: teardown-sequence
    functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        name: teardown-sequence
      spec:
        target: Default
        source: |
          oxr = option("params").oxr

          # Reference the actual EKS cluster managed resource instead of the composite
          applicationset_usage = {
            apiVersion = "apiextensions.crossplane.io/v1alpha1"
            kind = "Usage"
            metadata.name = oxr.metadata.name + "-applicationset-usage"
            spec = {
              of = {
                apiVersion = "kubernetes.crossplane.io/v1alpha2"
                kind = "Object"
                resourceRef.name = oxr.metadata.name + "-xplane-argocd-applicationset"
              }
              by = {
                apiVersion = "eks.aws.upbound.io/v1beta1"
                kind = "Cluster"
                resourceRef.name = oxr.spec.eksClusterRef + "-xplane-eks-cluster"
              }
            }
          }

          items = [applicationset_usage]
  - step: auto-ready
    functionRef:
      name: function-auto-ready
  - step: creation-sequence
    functionRef:
      name: function-sequencer
    input:
      apiVersion: sequencer.fn.crossplane.io/v1beta1
      kind: Input
      metadata:
        name: creation-sequence
        namespace: eksac
      rules:
      - sequence:
        - "eks-addons"
        - "s3-bucket-velero"
        - "efs-filesystem"
        - "xplane-argocd-applicationset"
