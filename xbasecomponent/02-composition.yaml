apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  name: x-basecomponent
spec:
  compositeTypeRef:
    apiVersion: consumable.trustbank.sg/v1alpha1
    kind: xBaseComponent
  mode: Pipeline
  pipeline:
  - step: install-eks-addons
    functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        name: "eks-addons"
      spec:
        target: Default
        source: |
          import json
          
          oxr = option("params").oxr
          # ocds = option("params").ocds
          
          region = oxr.spec.location
          
          # Default configuration values for different addons
          default_configs = {
            "aws-ebs-csi-driver": {
              controller = {
                tolerations = [
                  {
                    key = "karpenter.sh/nodepool"
                    operator = "Equal"
                    value = "infra"
                    effect = "NoSchedule"
                  }
                ]
              }
            }
            "aws-efs-csi-driver": {
              controller = {
                tolerations = [
                  {
                    key = "karpenter.sh/nodepool"
                    operator = "Equal"
                    value = "infra"
                    effect = "NoSchedule"
                  }
                ]
              }
            }
          }
          
          # Create addon resources for each addon in the list
          items = [
            {
              apiVersion = "eks.aws.upbound.io/v1beta1"
              kind = "Addon"
              metadata.name = oxr.metadata.name + "-" + addon.name.replace("_", "-") + "-addon"
              spec = {
                forProvider = {
                  addonName = addon.name
                  addonVersion = addon.version
                  region = region
                  clusterNameRef.name = oxr.spec.eksClusterRef + "-xplane-eks-cluster"
                  resolveConflicts = "OVERWRITE"
                  # Only set configurationValues if there are actual values to configure
                  configurationValues = json.encode(addon.configurationValues if addon.configurationValues else (default_configs[addon.name] if addon.name in default_configs else {})) if (addon.configurationValues or (addon.name in default_configs and default_configs[addon.name])) else Undefined
                  tags = {
                    Name = oxr.metadata.name + "-" + addon.name + "-addon"
                    ManagedBy = "crossplane"
                  }
                }
                providerConfigRef.name = "provider-aws-eks"
              }
            }
            for addon in (oxr.spec.eksAddons or [])
          ]
  - step: create-s3-bucket-for-velero
    functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        name: "s3-bucket-velero"
      spec:
        target: Default
        source: |
          oxr = option("params").oxr
          
          cluster_name = oxr.spec.eksClusterRef + "-xplane-eks-cluster"
          region = oxr.spec.location
          
          # Only create S3 bucket if Velero is enabled
          items = [
            {
              apiVersion = "s3.aws.upbound.io/v1beta2"
              kind = "Bucket"
              metadata = {
                name = oxr.metadata.name + "-velero-backup-bucket"
                annotations = {
                  "crossplane.io/external-name" = cluster_name + "-velero-backup"
                }
              }
              spec = {
                forProvider = {
                  region = region
                  tags = {
                    Name = cluster_name + "-velero-backup"
                    ManagedBy = "crossplane"
                    Purpose = "velero-backup"
                    "kubernetes.io/cluster/" + cluster_name = "owned"
                  }
                }
                providerConfigRef.name = "provider-aws-s3"
              }
            }
          ] if (oxr.spec.enableVelero or False) else []
  - step: create-efs-filesystem
    functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        name: "efs-filesystem"
      spec:
        target: Default
        source: |
          oxr = option("params").oxr
          
          cluster_name = oxr.spec.eksClusterRef + "-xplane-eks-cluster"
          region = oxr.spec.location
          
          # Only create EFS if EFS CSI driver is enabled
          items = [
            {
              apiVersion = "efs.aws.upbound.io/v1beta1"
              kind = "FileSystem"
              metadata.name = oxr.metadata.name + "-efs-filesystem"
              spec = {
                forProvider = {
                  region = region
                  performanceMode = "generalPurpose"
                  throughputMode = "provisioned"
                  provisionedThroughputInMibps = 100
                  tags = {
                    Name = cluster_name + "-efs"
                    ManagedBy = "crossplane"
                    Purpose = "efs-csi-driver"
                  }
                }
                providerConfigRef.name = "provider-aws-efs"
              }
            }
          ] if (oxr.spec.enableEFSCSIDriver or False) else []
  - step: create-argocd-applicationset
    functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        name: "xplane-argocd-applicationset"
      spec:
        target: Default
        source: |
          import json
          oxr = option("params").oxr
          ocds = option("params").ocds
          labels = oxr.metadata?.labels or {}
          
          cluster_name = oxr.spec.eksClusterRef + "-xplane-eks-cluster"
          region = oxr.spec.location or "unknown"
          aws_account_id = oxr.spec.awsAccountId or "unknown"
          
          # Get S3 bucket name if Velero is enabled
          _s3_bucket_name = ""
          if oxr.spec.enableVelero:
              s3_bucket_resource = ocds[oxr.metadata.name + "-velero-backup-bucket"]?.Resource
              _s3_bucket_name = s3_bucket_resource?.status?.atProvider?.id or ""
          
          # Get EFS filesystem ID if EFS CSI driver is enabled
          _efs_filesystem_id = ""
          if oxr.spec.enableEFSCSIDriver:
              efs_resource = ocds[oxr.metadata.name + "-efs-filesystem"]?.Resource
              _efs_filesystem_id = efs_resource?.status?.atProvider?.id or ""

          # Build base parameters
          base_parameters = [
            {
              name = "cluster.name"
              value = cluster_name
            },
            {
              name = "cluster.region"
              value = region
            },
            {
              name = "cluster.awsAccountId"
              value = aws_account_id
            }
          ]
          
          # Add Velero S3 bucket parameter if enabled
          velero_parameters = [
            {
              name = "velero.s3BucketName"
              value = _s3_bucket_name
            }
          ] if oxr.spec.enableVelero and _s3_bucket_name else []
          
          # Add EFS filesystem ID parameter if enabled
          efs_parameters = [
            {
              name = "efs.filesystemId"
              value = _efs_filesystem_id
            }
          ] if oxr.spec.enableEFSCSIDriver and _efs_filesystem_id else []
          
          # Combine all parameters
          all_parameters = base_parameters + velero_parameters + efs_parameters

          items = [{
            apiVersion = "kubernetes.crossplane.io/v1alpha2"
            kind = "Object"
            metadata.name = oxr.metadata.name + "-xplane-argocd-applicationset"
            spec = {
              forProvider = {
                manifest = {
                  apiVersion = "argoproj.io/v1alpha1"
                  kind = "ApplicationSet"
                  metadata = {
                    name = cluster_name + "-base-components"
                    namespace = "argocd"
                    labels = {
                      "app.kubernetes.io/name" = cluster_name + "-base-components"
                      "app.kubernetes.io/part-of" = "argocd"
                    }
                    finalizers = [
                      "resources-finalizer.argocd.argoproj.io"
                    ]
                  }
                  spec = {
                    goTemplate = True
                    goTemplateOptions = ["missingkey=error"]
                    generators = [
                      {
                        git = {
                          repoURL = "https://github.com/xawei/EKSaC"
                          revision = "HEAD"
                          files = [
                            {
                              path = "base-components/dev/" + cluster_name + "/*.yaml"
                            }
                          ]
                         # Per-application dynamic params (map[string]string).
                         # Key must equal the Application name (filename without .yaml).
                         values = {
                           "aws-load-balancer-controller" = json.encode([
                             {
                               name = "clusterName"
                               value = cluster_name
                             },
                             {
                               name = "region"
                               value = region
                             },
                             {
                               name = "valuesObjectJSON"
                               value = json.encode({
                                 serviceAccount = {
                                   annotations = {
                                     "eks.amazonaws.com/role-arn" = "arn:aws:iam::" + aws_account_id + ":role/ALBControllerRole-" + cluster_name
                                   }
                                 }
                               })
                             }
                           ])
                           "aws-ebs-csi-driver" = json.encode([
                             {
                               name = "valuesObjectJSON"
                               value = json.encode({
                                 controller = {
                                   serviceAccount = {
                                     annotations = {
                                       "eks.amazonaws.com/role-arn" = "arn:aws:iam::" + aws_account_id + ":role/EbsCsiRole-" + cluster_name
                                     }
                                   }
                                 }
                               })
                             }
                           ])
                           "aws-efs-csi-driver" = json.encode([
                             {
                               name = "fileSystemId"
                               value = _efs_filesystem_id
                             },
                             {
                               name = "valuesObjectJSON"
                               value = json.encode({
                                 controller = {
                                   serviceAccount = {
                                     annotations = {
                                       "eks.amazonaws.com/role-arn" = "arn:aws:iam::" + aws_account_id + ":role/EfsCsiRole-" + cluster_name
                                     }
                                   }
                                 }
                               })
                             }
                           ]) if (oxr.spec.enableEFSCSIDriver and _efs_filesystem_id) else Undefined
                           "external-dns" = json.encode([
                             {
                               name = "clusterName"
                               value = cluster_name
                             },
                             {
                               name = "valuesObjectJSON"
                               value = json.encode({
                                 serviceAccount = {
                                   annotations = {
                                     "eks.amazonaws.com/role-arn" = "arn:aws:iam::" + aws_account_id + ":role/ExternalDNS-" + cluster_name
                                   }
                                 }
                               })
                             }
                           ])
                           "velero" = json.encode([
                             {
                               name = "s3BucketName"
                               value = _s3_bucket_name
                             },
                             {
                               name = "regionBackup"
                               value = region
                             },
                             {
                               name = "regionSnapshot"
                               value = region
                             },
                             {
                               name = "valuesObjectJSON"
                               value = json.encode({
                                 serviceAccount = {
                                   server = {
                                     annotations = {
                                       "eks.amazonaws.com/role-arn" = "arn:aws:iam::" + aws_account_id + ":role/VeleroRole-" + cluster_name
                                     }
                                   }
                                 }
                               })
                             }
                           ]) if oxr.spec.enableVelero else Undefined
                         }
                        }
                      }
                    ]
                    template = {
              metadata = {
                name = "{{ trimSuffix \".yaml\" .path.filenameNormalized }}"
                annotations = { "argocd.argoproj.io/sync-wave" = "{{ .wave }}" }
              }
              spec = {
                project = "default"
                destination = { server = "https://kubernetes.default.svc", namespace = "{{ .namespace }}" }
                sources = []
                syncPolicy = {
                  automated  = { prune = True, selfHeal = True }
                  syncOptions = ["CreateNamespace=true", "Replace=true"]
                }
              }
            }

                    templatePatch = """
                      {{- $chartName := trimSuffix ".yaml" .path.filenameNormalized }}
                      {{- $hasHelm := index $ "helm" }}
                      {{- $hasValuesForChart := (and (index . "values") (index .values $chartName)) }}
                      
                      spec:
                        sources:
                          - repoURL: '{{ .repoURL }}'
                            targetRevision: '{{ .targetRevision }}'
                            {{- if $hasHelm }}
                            chart: {{ .helm.chart }}
                            helm:
                              {{- $baseValues := (index .helm "values") | default (dict) }}
                              {{- $extra := dict }}
                              {{- if $hasValuesForChart }}
                              {{- range $p := fromJson (index .values $chartName) }}
                              {{- if eq $p.name "valuesObjectJSON" }}
                              {{- $extra = fromJson (printf "%v" $p.value) }}
                              {{- end }}
                              {{- end }}
                              {{- end }}
                              valuesObject: {{ toJson (merge $baseValues $extra) }}
                              {{- if index .helm "valueFiles" }}
                              valueFiles: {{ toJson .helm.valueFiles }}
                              {{- end }}
                              parameters:
                              {{ if $hasValuesForChart }}
                              {{ range $parameter := fromJson (index .values $chartName) }}
                              {{- if ne $parameter.name "valuesObjectJSON" }}
                              {{ $helm := index $ "helm" }}
                              {{ if $helm }}
                              {{ $po := index $helm "parameterOverrides" }}
                              {{ if $po }}
                              {{ $mapped := index $po $parameter.name }}
                              {{ if $mapped }}
                              - name: {{ $mapped }}
                                value: '{{ printf "%v" $parameter.value }}'
                              {{ else }}
                              - name: {{ $parameter.name }}
                                value: '{{ printf "%v" $parameter.value }}'
                              {{ end }}
                              {{ else }}
                              - name: {{ $parameter.name }}
                                value: '{{ printf "%v" $parameter.value }}'
                              {{ end }}
                              {{ else }}
                              - name: {{ $parameter.name }}
                                value: '{{ printf "%v" $parameter.value }}'
                              {{ end }}
                              {{- end }}
                              {{ end }}
                              {{ end }}
                               # removed cluster-wide parameter injection; rely on per-app parameterOverrides
                            {{- end }}
                            {{- if index . "repoPath" }}
                            path: {{ .repoPath }}
                            {{- end }}
                        {{- if and $hasHelm (index .helm "valueFilesSource") }}
                          - {{ toJson .helm.valueFilesSource }}
                        {{- end }}
                    """
                  }
                }
              }
              managementPolicies = ["Create", "Update", "Observe", "Delete"]
              providerConfigRef.name = oxr.spec.eksClusterRef + "-providerconfig-kubernetes"
            }
          }]
  - step: create-iam-roles-and-associations
    functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        name: "iam-roles-and-podidentity"
      spec:
        target: Default
        source: |

          import json
          oxr = option("params").oxr

          cluster_name = oxr.spec.eksClusterRef + "-xplane-eks-cluster"
          aws_account_id = oxr.spec.awsAccountId

          trust_policy = {
            "Version" = "2012-10-17"
            "Statement" = [
              {"Effect" = "Allow", "Principal" = {"Service" = "pods.eks.amazonaws.com"}, "Action" = "sts:AssumeRole"}
            ]
          }

          apps = [
            { name = "aws-ebs-csi-driver", ns = "kube-system", sa = "ebs-csi-controller-sa", role = "EbsCsiRole-" + cluster_name, awsManaged = ["arn:aws:iam::aws:policy/service-role/AmazonEBSCSIDriverPolicy"] },
            { name = "aws-efs-csi-driver", ns = "kube-system", sa = "efs-csi-controller-sa", role = "EfsCsiRole-" + cluster_name, awsManaged = ["arn:aws:iam::aws:policy/service-role/AmazonEFSCSIDriverPolicy"] },
            { name = "aws-load-balancer-controller", ns = "kube-system", sa = "aws-load-balancer-controller", role = "ALBControllerRole-" + cluster_name, awsManaged = ["arn:aws:iam::aws:policy/AWSLoadBalancerControllerIAMPolicy"] },
            { name = "external-dns", ns = "external-dns", sa = "external-dns-sa", role = "ExternalDNS-" + cluster_name, awsManaged = ["arn:aws:iam::aws:policy/AmazonRoute53FullAccess"] },
            { name = "velero", ns = "velero", sa = "velero-server", role = "VeleroRole-" + cluster_name, awsManaged = ["arn:aws:iam::aws:policy/AmazonS3FullAccess", "arn:aws:iam::aws:policy/AmazonEC2FullAccess"] },
          ]

          custom_policy_doc = {
            "Version" = "2012-10-17",
            "Statement" = [ {"Effect" = "Allow", "Action" = ["sts:TagSession"], "Resource" = "*"} ]
          }

          roles = [
            {
              apiVersion = "iam.aws.upbound.io/v1beta1",
              kind = "Role",
              metadata = { generateName = app.name + "-", annotations = {"krm.kcl.dev/composition-resource-name" = app.role, "crossplane.io/external-name" = app.role} },
              spec = {
                forProvider = { assumeRolePolicy = json.encode(trust_policy), tags = { ManagedBy = "crossplane", App = app.name } },
                providerConfigRef = { name = "provider-aws-iam" }
              },
            }
            for app in apps
          ]

          policies = [
            {
              apiVersion = "iam.aws.upbound.io/v1beta1",
              kind = "Policy",
              metadata = { annotations = {"krm.kcl.dev/composition-resource-name" = app.role + "-policy"} },
              spec = {
                forProvider = { description = "Cluster policy for " + app.name, policy = json.encode(custom_policy_doc) },
                providerConfigRef = { name = "provider-aws-iam" }
              },
            }
            for app in apps
          ]

          attachments_aws = [
            {
              apiVersion = "iam.aws.upbound.io/v1beta1",
              kind = "RolePolicyAttachment",
              metadata = {
                generateName = app.name + "-aws-"
                annotations = {"krm.kcl.dev/composition-resource-name" = app.name + "-aws-attach-" + arn}
              },
              spec = {
                forProvider = { policyArn = arn, role = app.role },
                providerConfigRef = { name = "provider-aws-iam" }
              }
            }
            for app in apps
            for arn in (app.awsManaged or [])
          ]

          attachments_custom = [
            {
              apiVersion = "iam.aws.upbound.io/v1beta1",
              kind = "RolePolicyAttachment",
              metadata = { generateName = app.name + "-custom-", annotations = {"krm.kcl.dev/composition-resource-name" = app.name + "-custom-attach"} },
              spec = { forProvider = { policyArn = "arn:aws:iam::" + aws_account_id + ":policy/" + app.role + "-policy", role = app.role }, providerConfigRef = { name = "provider-aws-iam" } },
            }
            for app in apps
          ]

          associations = [
            {
              apiVersion = "eks.aws.upbound.io/v1beta1",
              kind = "PodIdentityAssociation",
              metadata = { generateName = app.name + "-pod-identity-", annotations = {"krm.kcl.dev/composition-resource-name" = app.name + "-pod-identity"} },
              spec = { forProvider = { clusterNameRef = { name = cluster_name }, namespace = app.ns, serviceAccount = app.sa, roleArn = "arn:aws:iam::" + aws_account_id + ":role/" + app.role }, providerConfigRef = { name = "provider-aws-eks" } },
            }
            for app in apps
          ]

          items = roles + policies + attachments_aws + attachments_custom + associations
  - step: teardown-sequence
    functionRef:
      name: function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLInput
      metadata:
        name: teardown-sequence
      spec:
        target: Default
        source: |
          oxr = option("params").oxr

          # Reference the actual EKS cluster managed resource instead of the composite
          applicationset_usage = {
            apiVersion = "apiextensions.crossplane.io/v1alpha1"
            kind = "Usage"
            metadata.name = oxr.metadata.name + "-applicationset-usage"
            spec = {
              of = {
                apiVersion = "kubernetes.crossplane.io/v1alpha2"
                kind = "Object"
                resourceRef.name = oxr.metadata.name + "-xplane-argocd-applicationset"
              }
              by = {
                apiVersion = "eks.aws.upbound.io/v1beta1"
                kind = "Cluster"
                resourceRef.name = oxr.spec.eksClusterRef + "-xplane-eks-cluster"
              }
            }
          }

          items = [applicationset_usage]
  - step: auto-ready
    functionRef:
      name: function-auto-ready
  - step: creation-sequence
    functionRef:
      name: function-sequencer
    input:
      apiVersion: sequencer.fn.crossplane.io/v1beta1
      kind: Input
      metadata:
        name: creation-sequence
        namespace: eksac
      rules:
      - sequence:
        - "eks-addons"
        - "s3-bucket-velero"
        - "efs-filesystem"
        - "xplane-argocd-applicationset"
        - "iam-roles-and-podidentity"
